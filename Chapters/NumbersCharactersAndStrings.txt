====== TraductionPclNumbersCharactersAndStrings ======
Created samedi 16/12/2006

====== Les nombres, caractères et chaînes de caractères ======

Bien que les fonctions, les variables, les macros et 25 opérateurs spéciaux fournissent les blocs de base du langage lui-même, les blocs de votre programme seront les structures de données que vous utilisez. Comme le faisait remarquer Fred Brooks dans //Le mythe du mois-homme//, « La représentation //est// l'essence de la programmation. »

Common Lisp fournit un support de base pour la plupart des types de données que l'on trouve typiquement dans les langages modernes : les nombres (entiers, à virgule flottante et complexes), les caractères, les chaînes de caractères, les tableaux (dont les tableaux à plusieurs dimensions), les listes, les tables de hashage, les flux d'entrée et sortie et une abstraction pour représenter portablement des noms de fichiers. Les fonctions sont également un type de donnée de première classe en Lisp -- elles peuvent être stockées dans des variables, passées en arguments, renvoyées comme valeur de retour et créées durant l'exécution.

Et ces types intégrés ne sont que le début. Ils sont définis dans le standard du langage pour que les programmeurs puissent compter sur leur présence et parce qu'ils ont tendance à être plus facile à implémenter efficacement lorsqu'ils sont étroitement liés au reste de l'implémentation. Mais comme vous le verrez dans les chapîtres suivants, Common Lisp fournit également plusieurs façons de définir vos propres types de données, de définir leurs opérations et de les intégrer avec les types intégrés(Td:?).

Mais pour l'instant, vous allez commencer par les types intégrés. Parce que Lisp est un langage de haut niveau, les détails d'implémentation des différentes types de données sont en grande partie cachés. De votre point de vue d'utilisateur du langage, les types intégrés sont définis par les fonctions qui opèrent dessus. Donc, pour apprendre un type de donnée, vous n'avez qu'à en apprendre sur les fonctions avec lesquelles vous pouvez l'utiliser. De pus, la plupart des types intégrés ont une syntaxe spéciale que le lecteur Lisp comprend et que l'imprimeur Lisp utilise. C'est pour ça, par exemple, que vous vous pouvez écrire des chaînes comme "foo", des nombres comme 123, 1/23 et 1.23 et des listes comme (a b c). Je décrirai la syntaxe pour les différents type d'objets quand décris les fonctions pour les manipuler.

Dans ce chapître, je couvrirai les types intégrés de données « scalaires » : nombres, caractères et chaînes. Techniquement, les chaînes ne sont pas de véritables scalaires -- une chaîne est une séquence de caractères, et vous pouvez accéder aux caractères individuellement et manipuler des chaînes avec une fonction qui opère sur des séquences. Mais je parlerai ici des chaînes parce que la plupart des functions spécifiques aux chaînes les manipulent comme valeurs de chaîne et aussi à cause de l'étroite relation entre plusieurs des functions de chaînes et leur contrepartie pour les caractères.

===== Les nombres =====

Les maths, comme le dit Barbie, sont difficiles. Common Lisp ne peut pas rendre le côté maths plus facile, mais il a tendance à nettement moins se mettre en travers du chemin que d'autres langages de programmation. Ce n'est pas une suprise vu son héritage mathématique. Lisp a été initialement conçu par un mathématicien comme un outil pour étudier des fonctions mathématiques. Et un des principaux projets du projet MAC au MIT était le système d'algèbre symbolique Macsyma, écrit en Maclisp, un des prédecesseurs directs de Common Lisp. De plus, Lisp a été utilisé comme un langage d'apprentissage à des endroits comme le MIT, où même les professeurs d'informatique frémissent à l'idée de dire à leurs étudiants que 10/4 = 2, d'où le support dans Lisp des fractions exactes. Et à plusieurs reprises Lisp a été appelé pour se mesurer à FORTRAN dans l'arène des calculs numériques à haute performance.

Une des raisons qui fait de Lisp langage agréable pour les maths est que ses nombres se comportent plus que de vrais nombres mathématiques que comme les approximations de nombres qui sont faciles à implémenter dans un matériel informatique fini. Par exemple, les entiers dans Common Lisp peuvent presque être arbitrairement grands plutôt que d'être limités par la taille d'un mot machine. Et diviser deux entiers donne une fraction exacte, pas une valeur tronquée. Et comme les fractions sont représentées par des paires d'entiers de taille arbitraire, les fractions peuvent représenter des fractions arbitrairement précises.

D'un autre côté, pour de la programmation numérique à haute performance, vous pourriez vouloir laisser la précision des rationels pour la vitesse offerte par l'utilisation des opérations en virgule flottante du matériel sous-jacent. Donc, Common Lisp offre également plusieurs types de nombres en virgule flottante, qui sont liés par l'implémentation aux représentations appropriées en virgule flottante supportées matériellement. Les flottants sont également utilisés pour représenter le résultat d'un calcul dont la vrai valeur mathématique serait un nombre irrationnel.

Enfin, Common Lisp supporte les nombres complexes -- les nombres que l'on obtient en faisant des choses comme prendre les racines carrées ou les logarithmes de nombres négatifs. Le standard Common Lisp va même jusqu'à spécifier les valeurs principales et les branches de coupure pour les fonctions irrationnelles et transcendentales dans le domaine complexe.

===== Les nombres littéraux =====

Vous pouvez écrire des nombrse littéraux de nombreuses façons ; vous en avez vu quelques exemples au Chapître 4. Néanmoins, il est important de garder en tête la division du travail entre le lecteur Lisp et l'évaluateur Lisp -- le lecteur est chargé de traduire le texte en objets Lisp et l'évaluateur s'occupe alors uniquement de ces objets. Pour un nombre donné d'un type donné, il peut y avoir de nombreuses représentations textuelles différentes, toutes étant traduites dans la même représentation objet par le lecteur Lisp. Par exemple, vous pouvez écrire l'entier 10 comme 20, 20/2, #xA ou tout un tas d'autres manières, mais le lecteur les traduira toutes en le même objet. Quand les nombres sont imprimés en retour -- disons, sur la REPL -- ils sont imprimés dans une syntaxe textuelle canonique qui peut très bien être différente de la syntaxe utilisée pour entrer le nombre. Par exemple :

CL-USER> 10
10
CL-USER> 20/2
10
CL-USER> #xa
10

La syntaxe pour les valeurs entières est un sign optionnel (+ ou -) suivi par un ou plusieurs chiffres. Les fractions sont écrites avec signe optionnel et une séquence de chiffres, représentant le numérateur, une barre oblique (/) et une autre séquence de chiffres représentant le dénominateur. Tous les nombres rationnels sont « canoniqués » lorsqu'ils sont lus -- c'est pour ça que 10 et 20/2 sont tous les deux lus comme le même nombre, comme le sont 3/4 et 6/8. Les rationnels sont imprimés dans une forme « réduite » -- les valeurs entières sont imprimées en syntaxe entière et les fractions avec le numérateur et le dénominateur réduit aux plus petits termes.

Il est aussi possible d'écrire des rationnels dans des bases autres que 10. S'il est précédé de #B ou #b, un rationnel littéral est lu comme un nombre binaire avec 0 et 1 comme seuls chiffres légaux. Un #O ou #o indique un nombre octal (chiffres légaux 0-7) et #X ou #x indique un hexadécimal (chiffres légaux 0-F ou 0-f). Vous pouvez écrire des rationnels dans d'autres bases de 2 à 36 avec #nR où //n// est la base (toujours écrit en décimal). Les chiffres « supplémentaires » au-delà de 9 sont pris parmi les lettres A-Z ou a-z. Notez que ces indicateurs de racine s'appliquent à tout le rationnel -- il n'est pas possible d'écrire une fraction avec le numérateur dans une base et le dénominateur dans une autre. Vous pouvez également écrire des valeurs entières, mais pas des fractions, comme des nombres décimaux terminés par un point décimal. Voici quelques exemples de rationnels avec leur représentation décimal, canonique :

123                            ==> 123
+123                           ==> 123
-123                           ==> -123
123.                           ==> 123
2/3                            ==> 2/3
-2/3                           ==> -2/3
4/6                            ==> 2/3
6/3                            ==> 2
#b10101                        ==> 21
#b1010/1011                    ==> 10/11
#o777                          ==> 511
#xDADA                         ==> 56026
#36rABCDEFGHIJKLMNOPQRSTUVWXYZ ==> 8337503854730415241050377135811259267835

Vous pouvez aussi écrire des nombre à virgule flottante de bien des façons. Contrairement aux nombre rationnels, la syntaxe utilisée pour décrire un nombre à virgule flottante peut affecter le type du nombre lu. Common Lisp définit quatre sous-types de nombre à virgule flottante : short, single, double et long (court, simple, double et long). Chaque sous-type peut utiliser un nombre de bits différent pour sa représentation, ce qui implique que chaque sous-type peut représenter des valeurs qui occupent un intervalle différent et avec un précision différente. Plus de bits permettent un intervalle plus grand et une meilleure précision.

Le format de base pour les nombres à virgule flottante est un signe optionnel suivi par une séquence non-vide de chiffres décimaux comprenant éventuellement un point décimal. Cette séquence peut être suivie par un marqueur d'exposant de « notation scientifique informatique ». La marqueur d'exposant consiste en une seule lettre suivi par un signe optionnel est une séquence de chiffres, interprétés comme la puissance de dix par laquelle le nombre avant le marqueur d'exposant devrait être multiplié. La lettre a un double rôle : elle marque le début de l'exposant et indique quelle représentation à virgule flottante doit être utilisée pour le nombre. Les marqueurs d'exposant s, f, d et l (et leur équivalents en majuscule) indiquent des flottants short, single, double et long. La lettre e indique que la représentation par défaut (single-float, au départ) devrait être utilisée.

===== Chaînes de caractères =====

Ainsi qu'il en a été fait mention plus haut, en Common Lisp, les chaînes de caractère sont en fait un type de données composite. En l'occurrence, il s'agit de tableaux de caractères unidimensionnels. Par conséquent, j'évoquerai la plupart des choses qu'on peut réaliser avec des chaînes de caractères dans le prochain chapitre, lorsque je discuterai des nombreuses fonctions permettant de manipuler les séquences, parmi lequelles les chaînes de caractères ne constituent qu'un exemple. Mais les chaînes de caractères ont aussi leur propre syntaxe litérale, ainsi qu'une bibliothèque de fonctions permettant d'effectuer des opérations qui leurs sont spécifiques. Je discuterai de ces aspects particuliers des chaînes de caractères dans le présent chapitre et réserverai les autres au chapitre 11.

Comme vous avez pu le constater, les chaînes littérales sont écrites entre guillemets doubles. Vous pouvez inclure n'importe quel caractère compris dans le jeu de caractères dans une chaîne littérale, mis à part le guillemet double (") et la barre oblique inversée ou backslash (\). Et vous pouvez également inclure ces deux-là si vous les échappez à l'aide du backslash. En fait, le backslash échappe n'importe quel caractère, bien que cela soit ne soit pas nécessaire pour d'autres caractères que le guillemet et le slash inversé lui-même. Le tableau 10-2 montre comment diverses chaînes littérales seront lues par le lecteur Lisp.

Notez qu'en général, la REPL imprimera à l'écran les chaînes de caractères sous une forme lisible, en l'entourant de guillemets doubles et ajoutant tout backslash nécessaire. Aussi, si vous souhaitez visualiser le contenu d'une chaîne de caractères, vous devrez utiliser une fonction comme FORMAT, permettant d'afficher à l'écran un résultat lisible par l'utilisateur. Par exemple, voici ce que vous verrez si vous entrez dans le REPL une chaîne contenant un guillemet :

CL-USER> "foo\"bar"
"foo\"bar"

FORMAT, en revanche, retournera le contenu véritable de la chaîne de caractères :

CL-USER> (format t "foo\"bar")
foo"bar
NIL
