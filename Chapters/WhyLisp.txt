====== TraductionPcl ======
Created samedi 16/12/2006

cf. [[TraductionPclConventions]]

====== Introduction : pourquoi Lisp ? ======

Si vous pensez que le plus grand plaisir dans la programmation est de pouvoir accomplir un maximum de choses avec un code qui exprime simplement et clairement vos intentions, alors programmer en Common Lisp est sûrement la chose la plus amusante que vous puissiez faire avec un ordinateur. Vous serez plus efficace et plus rapide avec Common Lisp qu'avec n'importe quel autre langage.

C'est une affirmation osée. Comment la justifier ? Pas seulement avec ces quelques pages -- vous allez devoir apprendre un peu de Lisp et voir par vous-même -- d'où ce livre. Pour le moment, commençons par une preuve anecdotique, l'histoire de mon chemin jusqu'à Lisp. Puis, dans la section suivante, j'expliquerai quel est d'après moi le bénéfice que vous aurez à apprendre Common Lisp.

Je suis l'un de ce qui doit être un relativement petit nombre de hackers Lisp de seconde génération. Mon père a débuté dans l'informatique en écrivant un système d'exploitation en assembleur pour la machine qu'il utilisait pour collecter des données pour sa thèse de physique. Dans les années 80, après avoir utilisé des systèmes informatiques dans divers labos de physique, il avait complètement abandonné la physique et travaillait pour une grosse compagnie pharmaceutique. Cette société avait comme projet en cours de développer un logiciel pour modéliser les processus de production de ses usines chimiques -- si vous augmentez la taille de ce vaisseau, comment cela affecte-t-il la production annuelle ? L'équipe originelle, qui écrivait en FORTRAN, avait dilapidé la moitié du budget et pratiquement tout le temps alloué au projet sans aucun résultat en récompense de leurs efforts. Les années 80 voyaient alors l'explosion de l'intelligence artificielle (IA), et Lisp était dans l'air du temps. Et donc mon père -- qui n'était alors pas un Lispeur -- alla à la Carnegie Mellon University (CMU) pour parler avec l'un des gars qui travaillaient sur ce qui allait devenir Common Lisp pour savoir si Lisp pourrait être un bon langage pour son projet.

Les gars de la CMU lui montrèrent quelques démos des trucs sur lesquels ils travaillaient, et il fut convaincu. À son tour, il convainquit ses patrons de laisser son équipe reprendre le projet en échec et de le faire en Lisp. Un an plus tard, et en utilisant seulement ce qui restait du budget original, son équipe livra une application fonctionnelle avec des options que l'équipe originale avait abandonné de livrer. Mon père accorde le succès de son équipe à leur décision d'utiliser Lisp.

Cependant, ce n'est qu'une anecdote. Et peut-être mon père se trompe-t-il quant aux raisons de leur succès. Ou peut-être Lisp était-il meilleur seulement en comparaison des autres langages de l'époque. De nos jours, nous avons tout un tas de nouveau langages extraordinaires dont beaucoup ont incorporé des caractéristiques de Lisp. Suis-je vraiment en train d'affirmer que Lisp peut vous offrir les mêmes avantages qu'il a offert à mon père dans les années 80 ? Lisez la suite.

Malgré tous les efforts de mon père, je n'ai jamais rien appris de Lisp au lycée. Après une carrière qui n'impliquait pas vraiment de programmation dans quelque langage que ce soit, je fus séduit par le Web et m'intéressai de nouveau à l'informatique. J'ai travaillé d'abord en Perl, en apprenant assez pour devenir dangereux tout en ayant mis au point un forum de discussion en ligne pour le site Web du magazine //Mother Jones//, puis pour un magasin en ligne, Organic Online, où j'ai travaillé sur de gros -- pour l'époque -- sites Web tel que celui que Nike afficha durant les jeux olympiques de 1996. Plus tard, je me suis mis à Java en tant que jeune développeur chez WebLogic, qui fait maintenant partie de BEA. Après WebLogic, j'ai rejoint une autre start-up où j'étais le programmeur en chef d'une équipe qui mettait au point un système de messagerie transactionnel en Java. A cette époque, mon intérêt en général pour les langages de programmation m'amena à explorer des langages classiques tels que C, C++ et Python
aussi bien que certains langages moins connus tels que Smalltalk, Eiffel et Beta.

Je connaissais donc deux langages d'un bout à l'autre et était familier avec une douzaine d'autres. Pourtant, je réalisai qu'en fin de compte mon intérêt pour les langages de programmation était né de l'idée, inspirée par les récits sur Lisp de mon père -- que des langages différents étaient vraiment différents, et que, malgré l'équivalence formelle de Turing entre tous les langages de programmation, il est vraiment possible de faire plus, plus rapidement, avec certains langages et de prendre plaisir à le faire. Pourtant, ironiquement, je n'avais jamais vraiment passé beaucoup de temps sur Lisp lui-même. Je commençai donc à bricoler (NdT: « hacker ») avec Lisp à mes heures perdues. Et chaque fois que je le faisais, c'était grisant de voir à quelle vitesse je pouvais passer de l'idée à un code qui marche.

Par exemple, pendant les vacances, ayant à peu près une semaine pour bricoler Lisp, je décidai de m'essayer à écrire une version d'un programme -- un système pour élever des algorithmes génétiques pour jouer au Go -- que j'avais écrit au début de ma carrière de programmeur Java. Même handicapé par ma connaissance rudimentaire de Common Lisp et contraint à chercher mêmes les fonctions basiques, cela se révéla plus productif que si j'avais du réécrire le même programme en Java, même avec plusieurs années supplémentaire d'expérience avec Java, acquise depuis l'écriture de la première version.

Une expérience similaire amena à la bibliothèque dont je parlerai au chapitre 24. À mes débuts chez WebLogic, j'avais écrit une bibliothèque, en Java, pour disséquer des fichiers de classe Java. Cela marchait, mais le code était un peu désordonné et difficile à modifier ou à étendre. J'avais essayé de nombreuses fois, au fil des ans, de réécrire cette bibliothèque, pensant qu'avec mes compétences en Java qui ne cessaient de s'améliorer, je trouverais une manière d'y parvenir qui ne finirait pas en piles de code dupliqué. Je n'ai jamais trouvé la solution. Mais lorsque j'ai essayé de le faire en Common Lisp, en deux jours je me suis retrouvé non seulement avec un analyseur de fichiers de classe Java, mais avec une bibliothèque généraliste pour disséquer n'importe quel type de fichier binaire. Vous verrez comment cette bibliothèque fonctionne au chapitre 24 et vous l'utiliserez au chapitre 25 pour écrire un analyseur pour les balises ID3 intégrées dans les fichiers MP3.

===== Pourquoi Lisp ? =====

Il est difficile, en seulement quelques pages d'introduction, d'expliquer pourquoi ses utilisateurs apprécient un langage et il est encore plus difficile de démontrer pourquoi vous devriez prendre le temps d'apprendre un certain langage. Seule notre histoire personnelle nous y conduit. J'apprécie peut-être Lisp à cause de bizarreries dans la façon dont mon cerveau est câblé. Cela pourrait bien être génétique, puisque mon père a ça aussi. Aussi, avant de plonger dans l'apprentissage de Lisp, il est raisonnable de vouloir savoir quel en serait le bénéfice.

Pour certains langages, le bénéfice est évident. Par exemple, si vous voulez écrire du code de bas niveau pour Unix, vous devriez apprendre C. Et si vous voulez écrire certains types d'applications multi-plateformes, vous devriez apprendre Java. Et il y a tellement de sociétés qui utilisent énormément C++ que si vous voulez un emploi dans l'une d'entre elles, vous devriez apprendre C++.

Pour la plupart des langages, néanmoins, le bénéfice est plus dur à déterminer ; il est lié à des critères subjectifs, comme quel effet cela fait d'utiliser le langage. Les défenseurs de Perl aiment à dire que Perl « rend les choses faciles faciles et les choses difficiles possibles » et se réjouissent du fait que, comme le dit le slogan de Perl, « Il y a plus d'une façon de le faire. ». Les fans de Python, d'un autre côté, pensent que Python et propre et simple et que le code Python est plus facile à comprendre parce que, comme //leur// slogan le dit, « Il n'y a qu'une façon de le faire. ».

Alors, pourquoi Common Lisp ? Il n'y a pas de bénéfice évident à adopter Common Lisp comme il y en a pour C, Java et C++ (à moins, bien sûr, qu'il se trouve que vous possédiez une Lisp Machine). L'intérêt à utiliser Lisp a bien plus à voir avec l'expérience que l'on gagne à s'en servir. Je passerai le reste de ce livre à vous montrer les spécificités de Common Lisp et comment les utiliser pour voir par vous-même ce qu'il en est. Pour le moment, je vais essayer de vous donner une idée de la philosophie de Lisp.

Ce qui se rapproche le plus d'un slogan pour Common Lisp est une description à la façon d'un koan, « le langage de programmation programmable ». Bien que cryptique, cette description va à la racine du plus gros avantage que Common Lisp a encore sur d'autres langages. Plus qu'aucun autre langage, Common Lisp suit la philosophie selon laquelle ce qui est bon pour le concepteur du langage l'est aussi pour ses utilisateurs. Et de fait, quand vous programmez en Common Lisp, vous ne vous trouverez pratiquement jamais à souhaiter que le langage possède une quelconque caractéristique qui rendrait votre programme plus simple à écrire parce que, comme vous le verrez tout au long de ce livre, vous pourrez ajouter cette caractéristique vous-même.

En conséquence, un programme en Common Lisp a tendance à manifester une correspondance beaucoup plus claire entre vos idées sur le fonctionnement du programme et le code que vous écrivez effectivement. Vos idées ne sont pas obscurcies par du code type (NdT: boilerplate) et des idiomes répétés sans fin. Cela rend votre code plus facile à maintenir parce que vous n'avez pas à patauger à travers des monceaux de code à chaque fois que vous avez besoin de changer quelque chose. Même des changements systémiques du comportement d'un programme peuvent souvent être obtenus par des changements relativements légers du code lui-même. Cela signifie aussi que vous allez développer du code plus rapidement ; il y a moins de code à écrire, et vous ne gaspillez pas de temps à vous évertuer à trouver une façon élégante de vous exprimez malgré les limitations du langage.

Common Lisp est également un excellent langage pour la programmation exploratoire -- si vous ne savez pas exactement comment votre programme va fonctionner quand vous commencez à l'écrire, Common Lisp a de nombreuses caractéristiques qui vous aideront à développer votre code incrémentalement et interactivement.

En hors d'oeuvre, la boucle lis-éval-imprime, que j'introduirai dans le chapitre suivant, vous permet d'interagir continuellement avec votre programme alors que vous le développez. Écrivez une nouvelle fonction. Testez-la. Changez-la. Essayez une approche différente. Vous n'avez jamais besoin de vous arrêter à cause d'un long cycle de compilation.

Parmi les autres caractéristiques qui permettent un style de programmation coulant et interactif, il y a le typage dynamique de Lisp et le système de condition de Common Lisp. Grâce au premier, vous passez moins de temps à convaincre le compilateur que vous devriez avoir le droit d'exécuter votre code et plus de temps à effectivement le faire tourner et à travailler dessus et le second vous permet de développer même votre code de gestion d'erreur interactivement.

Une autre conséquence du fait d'être un « langage de programmation programmable » est que Common Lisp, en plus d'incorporer de légers changements qui rendent certains programmes particuliers plus faciles à écrire, peut facilement adopter des idées radicalement nouvelles sur le fonctionnement des langages de programmation. Par exemple, l'implémentation originelle du Common Lisp Object System (CLOS), le puissant système object de Common Lisp, était une bibliothèque écrite en Common Lisp portable. Cela permit aux programmeurs Lisp de gagner une véritable expérience avec les fonctionnalités qu'il fournissait, avant qu'il ne soit officiellement incorporé dans le langage.

Quelque soit le nouveau paradigme qui fasse son apparition ensuite, il est extrêmement probable que Common Lisp soit capable de l'absorber sans nécessiter aucun changement au noyau du langage. Par exemple, un Lispeur a récemment écrit une bibliothèque, AspectL, qui ajoute le support pour la programmation orientée aspect (POA) à Common Lisp. Si la POA s'avère être le prochain concept d'avenir, Common Lisp sera capable de le supporter sans aucun changement au langage de base et sans aucun préprocesseur additionnel ou compilateur additionnel.

===== Comment tout a commencé =====

Common Lisp est le déscendant moderne du langage Lisp conçu initialement par John !McCarthy en 1956. Lisp fut conçu aux alentours de 1956 pour le « traitement de données symboliques » et fut nommé d'après l'une des choses pour lesquelles il était plutôt bon : LISt Processing (traitement de liste). On a parcouru du chemin depuis lors : Common Lisp arbore toute la panoplie des types de données modernes que l'on peut souhaiter, un système de condition qui, comme vous le verrez au chapitre 19, fournit un niveau de flexibilité impossible à trouver dans les systèmes d'exception de langages tels que Java, Python et C++, de puissantes fonctionnalités pour la programmation orientée objet et de nombreuses fonctionnalités du langage qui n'existent simplement pas dans d'autres langages de programmation. Comment est-ce possible ? Qu'est-ce qui pourrait bien provoquer l'évolution d'un langage aussi bien équipé ?

Et bien !McCarthy était (et est toujours) un chercheur en intelligence artificielle (IA), et nombre des caractéristiques qu'il intégra dans sa version initiale du langage en firent un escellent langage pour la programmation en IA. Pendant le boum de l'IA dans les années 1980, Lisp resta un outil de choix pour les programmeurs qui écrivaient des logiciels pour résoudre des problèmes difficiles tels que les preuves de théorèmes automatisées, la planification et l'ordonnancement ou la vision par ordinateur. C'étaient des problèmes qui nécessitaient beaucoup de logiciels ardus à écrire ; pour les entamer, les programmeurs en IA avaient besoin d'un langage puissant, et ils ont fait de Lisp ce langage. La Guerre Froide a aidé -- alors que le Pentagone mettait de l'argent dans la Defense Advanced Research Projects Agency (DARPA), une bonne part fut versée à des gens qui travaillaient sur des problèmes tels que les simulations de champ de bataille à grande échelle, la planification automatique ou les interfaces en langage naturel. Ces gens utilisaient Lisp et continuèrent à le pousser à faire ce dont ils avaient besoin.

Les mêmes forces qui avaient alimenté l'évolution de Lisp repoussèrent ses limites dans d'autres directions -- les grands problèmes de l'IA consommaient de vastes ressources informatiques quelque soit la façon dont vous les codiez, et si vous appliquez la loi de Moore à l'envers sur 20 ans, vous pouvez imaginer combien les ressources informatiques étaient rares sur le matériel des années 80. Les utilisateurs de Lisp devaient trouver toutes sortes de moyens pour presser leurs implémentations pour obtenir de meilleures performances. Les implémentations Common Lisp modernes sont les héritières des efforts d'alors et comprennent souvent des compilateurs plutôt sophistiqués générant du code machine natif. Bien qu'aujourd'hui, grâce à la loi de Moore, il est possible d'obtenir des performances acceptables avec un langage purement interprété, ce n'est plus du tout un problème pour Common Lisp. Comme je le montrerai au chapître 32, avec les déclarations (optionnelles) appropriées, un bon compilateur Lisp peut générer du code machine assez semblable à ce qui serait généré par un compilateur C.

Les années 80 furent aussi l'ère des Machines Lisp, et plusieurs sociétés, dont la célèbre Symbolics, produisirent des ordinateurs qui exécutaient du code Lisp nativement sur leurs circuits. De fait, Lisp devint un langage de programmation système, utilisé pour écrire le système d'exploitation, des éditeurs, des compilateurs et à peu près tout ce qui tournait sur les Machines Lisp.

En fait, au début des années 80, avec les divers labos d'IA et les vendeurs de machines Lisp qui fournissaient leurs propres implémentations Lisp, il y avait une telle prolifération de systèmes et de dialectes Lisp que les gens au DARPA commencèrent à exprimer des inquiétudes sur la fragmentation de la communauté Lisp. Pour s'occuper de ce problème, un groupe local de hackers Lisp se forma en 1981 et amorça le processus de standardisation d'un nouveau langage appelée Common Lisp, alliant les meilleures caractéristiques des dialectes Lisp existants. Leur travail était documenté dans le livre //Common Lisp the Language// par Guy Steele (Digital Press, 1984) -- !CLtL pour les connaisseurs Lisp.

Dès 1986, les premières implémentations Common Lisp étaient disponibles, et le sort en était jeté pour les dialectes qu'il était censé remplacer. En 1996, le American National Standards Institute (ANSI) publia un standard pour Common Lisp qui se basait sur le langage spécifié dans CLtL et l'étendait, y ajoutant quelques caractéristiques majeures telles que le CLOS et le système de conditions. Mais même alors, ça n'était pas fini : comme !CLtL avant lui, le standard ANSI laisse sciemment de la marge aux implémenteurs pour expérimenter sur la meilleure façon de faire les choses : une implémentation Lisp complète fournit un riche environnement d'exécution avec accès à des widgets graphiques, de multiples fils d'exécution (threads), des sockets TCP/IP et plus encore. De nos jours, Common Lisp évolue largement comme d'autres langages open-source : ceux qui s'en servent écrivent les bibliothèques dont ils ont besoin et les rendent souvent disponibles aux autres. Dans les dernières années, en particulier, les bibliothèques open-source ont poussé comme des champignons.

Donc, d'un côté, Lisp est un des langages « classiques » de l'informatique, basé sur des idées qui ont résisté à l'épreuve du temps. De l'autre, c'est un langage d'usage général, résolument moderne, dont la conception réflète une approche profondément pragamatique pour la résolution de problèmes réels, de façon aussi efficace et robuste que possible. Le seul inconvénient de l'héritage « classique » de Lisp est qu'un tas de gens se baladent avec des idées sur Lisp basées sur un genre particulier de Lisp auquel ils ont été exposé à un moment donné du demi-siècle qui s'est écoulé depuis que !McCarthy a inventé Lisp. Si quelqu'un vous dit que Lisp est seulement interprété, qu'il est lent ou que vous devez utiliser la récursion pour n'importe quoi, demandez-lui de quel dialecte de Lisp il parle et si les gens portaient des pattes d'eph quand il l'a appris.

===== A qui s'adresse ce livre =====

Ce livre est pour vous  si Common Lisp vous rend curieux, que vous soyez convaincu de vouloir l'utiliser ou que vous vouliez juste savoir de quoi il s'agit.

Si vous avez déjà appris Lisp mais que vous aviez du mal à passer des exercices académiques à des véritables programmes, ce livre devrait vous y conduire. D'un autre côté, vous n'avez pas besoin d'être déjà convaincu de vouloir utiliser Lisp pour retenir quelque chose de ce livre.

Si vous êtes un pragmatique endurci qui veut savoir quels avantages Common Lisp a par rapport à d'autres langages tels que perl, Python, Java, C ou C#, ce livre devrait vous fournir de la matière. Ou peut-être que vous vous fichez de Lisp -- peut-être que vous êtes déjà certain que Lisp n'est pas vraiment mieux que n'importe quel autre langage que vous connaissez mais que vous êtes harcelé par un Lispeur qui vous dit que c'est parce que vous ne « saisissez pas ». Dans ce cas, ce livre vous offrira une introduction à Common Lisp qui va droit au but. Si, après avoir lu ce livre, vous pensez toujours que Common Lisp n'est pas mieux que vos langages préférés du moment, vous serez parfaitement en mesure d'expliquer précisément pourquoi.

J'expliquerai non seulement la syntaxe et la sémantique du langage, mais aussi comment l'utiliser pour écrire des logiciels qui font des choses utiles. Dans la première partie du livre, je décrirai le langage proprement dit, en glissant quelques chapitres « pratiques », où je vous montrerai comment écrire du véritable code. Puis, une fois que j'aurai expliqué la plupart du langage, y compris plusieurs parties que d'autres livres vous laissent comprendre par vous-même, je vous aiderai à écrire plusieurs programme de taille moyenne qui font vraiment des choses que vous pourriez trouver utiles : filtrer du spam, analyser des fichiers binaires, cataloguer des MP3s, streamer des MP3s sur un réseau et fournir une interface Web pour le catalogue et le serveur MP3, à travers les neuf autres chapitres du livre.

Quand vous aurez fini ce livre, vous serez familiers avec les plus importantes caractéristiques du langage et comment elle vont ensemble, vous aurez utilisé Common Lisp pour écrire plusieurs programmes non triviaux et vous serez bien préparés pour continuer à explorer le langage par vous-même. Bien que la route vers Lisp soit différente pour chacun, j'espère que ce livre aidera à vous faciliter le chemin. Alors, commençons.
