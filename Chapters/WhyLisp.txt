====== TraductionPcl ======
Created samedi 16/12/2006

cf. [[TraductionPclConventions]]

====== Introduction : pourquoi Lisp ? ======

Si vous pensez que le plus grand plaisir dans le fait de programmer vient de pouvoir faire le plus possible avec du code qui exprime simplement et clairement votre intention, alors programmer en Common Lisp devrait sûrement être ce que vous pourriez faire de plus amusant avec un ordinateur. Vous ferez plus et plus vite en l'utilisant que vous ne pourriez avec aucun autre langage.

C'est une affirmation osée. Est-ce que je peux la justifier ? Pas avec seulement les quelques pages de ce chapitre -- vous allez devoir apprendre un peu de Lisp et voir par vous-même -- d'où ce livre. Pour le moment, commençons par une preuve anecdotale, l'histoire de mon chemin jusqu'à Lisp. Puis, dans la section suivante, j'expliquerai quel bénéfice je pense que vous aurez à apprendre Common Lisp.

Je suis l'un de ce qui doit être un relativement petit nombre de hackers Lisp de seconde génération. Mon père débuta dans l'informatique en écrivant un système d'exploitation en assembleur pour la machine qu'il utilisait pour collecter des données pour sa thèse de physique. Après avoir utilisé des systèmes informatiques dans divers labos de physique, dans les années 80 il avait complètement quitté la physique et travaillait pour une grosse société pharmaceutique. Cette société avait comme projet en cours de développer un logiciel pour modéliser les processus de production de ses usines chimiques -- si vous augmentez la taille de ce vaisseau(Td: cette tubulure?),  comment cela affecte-t-il la production annuelle ? L'équipe originelle, qui écrivait en FORTRAN, avait dilapidé la moitié du budget et pratiquement tout le temps alloué au projet avec rien pour prouver leurs efforts. Comme c'était les années 80 et le milieu du boom de l'intelligence artificielle (IA), Lisp était dans l'air du temps. Et donc mon père -- pas un Lispeur à ce moment-là -- alla à la Carnegie Mellon University (CMU) pour parler avec quelqu'uns des gars(Td:?) qui travaillaient sur ce qui allait devenir Common Lisp pour savoir si Lisp pourrait être un bon langage pour ce projet.

Les gars de CMU lui montrèrent quelques démos des trucs sur lesquels ils travaillaient, et il fut convaincu. À son tour, il convainquit ses patrons de laisser son équipe reprendre le projet en échec et de le faire en Lisp. Un an plus tard, et en utilisant seulement ce qui restait du budget original, son équipe livra une application fonctionnelle avec des options que l'équipe originale avait abandonné de livrer. Mon père accorde le succès de son équipe à leur décision d'utiliser Lisp.

Maintenant, ce n'est qu'une anecdote. Et peut-être mon père se trompe-t-il à propos des raisons de leur succès. Ou peut-être que Lisp était meilleur seulement en comparaison des autres langages du moment. De nos jours, nous avons tout un tas de nouveau langages extraordinaires dont beaucoup ont incorporé des caractéristiques de Lisp. Est-ce que j'affirme vraiment que Lisp peut vous offrir les mêmes bénéfices qu'il a offert à mon père dans les années 80 ? Lisez la suite.

Malgré tous les efforts de mon père, je n'ai jamais appris aucun Lisp au lycée. Après une carrière qui ne comportait vraiment de programmation dans aucun langage, je fus séduit par le Web et de retour dans l'informatique. J'ai travaillé d'abord en Perl, apprenant assez pour devenir dangereux tout en ayant mis au point un forum de discussion en ligne pour le site Web du magazine //Mother Jones// et ensuite changé pour un magasin en ligne, Organic Online, où j'ai travaillé sur de gros -- pour l'époque -- sites Web tel que celui que Nike afficha durant les jeux olympiques de 1996. Plus tard je me suis mis à Java en tant parmi les premiers développeurs chez WebLogic, qui fait maintenant partie de BEA. Après WebLogic, j'ai rejoint une autre start-up où j'étais le programmeur en chef d'une équipe qui mettait au point un système de messagerie transactionnel en Java. Durant ce temps, mon intérêt en général pour les langages de programmation m'amena à explorer des langages classiques tels que C, C++ et Python aussi bien que des certains moins connus tels que Smalltalk, Eiffel et Beta.

Donc je connaissais deux langages d'un bout à l'autre et était familier avec une douzaine d'autres. Finalement, pourtant, je réalisai que mon intérêt pour les langages de programmation était enraciné dans l'idée, plantée par les récits sur Lisp de mon père -- que des langages différents étaient vraiment différents, et que, malgré l'équivalence formelle de Turing entre tous les langages de programmation, vous pouvez vraiment en faire plus, plus rapidement, dans certains langages et prendre du plaisir à le faire. Pourtant, ironiquement, je n'avais jamais vraiment passé beaucoup de temps sur Lisp lui-même. Je commençai donc à bricoler (NdT: hacking) avec Lisp sur mon temps libre. Et chaque fois que je le faisais, c'était grisant de voir à quelle vitesse je pouvais passer de l'idée à un code qui marche.

Par exemple, pendant des vacances, ayant à peu près une semaine pour bricoler Lisp, je décidai de m'essayer à écrire une version d'un programme -- un système pour élever des algorithmes génétiques pour jouer au Go -- que j'avais écrit au début de ma carrière de programmeur Java. Même handicapé par ma connaissance rudimentaire de Common Lisp et devant chercher mêmes les fonctions basiques, cela sembla plus productif que si j'avais du réécrire le même programme en Java, même avec plusieurs années en plus d'expérience avec Java, acquise depuis l'écriture de la première version.

Une expérience similaire amena à la bibliothèque dont je parlerai au chapitre 24. À mes débuts chez WebLogic, j'avais écrit une bibliothèque, en Java, pour disséquer des fichiers de classe Java. Cela marchait, mais le code était un peu en fouillis et difficile à modifier ou étendre. J'avais essayé de nombreuses fois, au fil des ans, de réécrire cette bibliothèque, pensant qu'avec mes compétences en Java qui ne cessaient de s'améliorer, je trouverais une manière d'y parvenir qui ne finirait pas en piles de code dupliqué. Je n'ai jamais trouvé la manière. Mais quand j'ai essayé de le faire en Common Lisp, il me fallut deux jours, et je me retrouvais non seulement avec un analyseur de de fichier de classe Java, mais avec une bibliothèque généraliste pour disséquer n'importe quel type de fichier binaire. Vous verrez comment cette bibliothèque fonctionne au chapitre 24 et vous l'utiliserez au chapitre 25 pour écrire un analyseur pour les balises ID3 intégrées dans les fichiers MP3.

===== Pourquoi Lisp ? =====

Il est difficile, en seulement quelques pages d'introduction, d'expliquer pourquoi ses utilisateurs apprécient un langage et il est encore plus difficile de démonter(Td:?) pourquoi vous devriez donner de votre temps pour apprendre un certain langage. Seule notre histoire personnelle nous y conduit. J'aime peut-être Lisp à cause de bizarreries dans la façon dont mon cerveau est câblé. Cela pourrait bien être génétique, puisque mon père a ça aussi. Aussi, avant de plonger dans l'apprentissage de Lisp, il est raisonnable de vouloir savoir ce que le bénéfice serait.

Pour certains langages, le bénéfice est évident. Par exemple, si vous voulez écritre du code bas niveau pour Unix, vous devriez apprendre C. Et si vous voulez écrire certains genres d'applications multi-plateformes, vous devriez apprendre Java. Et il y a tellement de sociétés qui utilisent beacoup de C++, donc si vous voulez un emploi dans l'une d'entre elles, vous devriez apprendre C++.

Pour la plupart des langages, néanmoins, le bénéfice est plus dur à déterminer ; il est lié à des critères subjectifs tel que l'effet que cela fait d'utiliser le langage. Les défenseurs de Perl aiment à dire que Perl « rend les choses faciles faciles et les choses difficiles possibles » et se réjouissent du fait que, comme le dit le slogan de Perl, « Il y a plus d'une façon de le faire. ». Les fans de Python, d'un autre côté, pensent que Python et propre et simple et pensent que du code Python est plus facile à comprendre parce que, comme //leur// slogan le dit, « Il n'y a qu'une façon de le faire. ».

Alors, pourquoi Common Lisp ? Il n'y a pas de bénéfice évident à adopter Common Lisp comme il y en a pour C, Java et C++ (à moins, bien sûr, qu'il se trouve que vous possédiez une Lisp Machine). L'intérêt à utiliser Lisp a bien plus à voir avec l'expérience que l'on retire à s'en servir(Td:?). Je passerai le reste de ce libre à vous montrer les spécificités de Common Lisp et comment les utiliser pour voir par vous-même ce qu'il en est. Pour le moment, je vais essayer de vous donner une idée de la philosophie de Lisp.

Ce que Common Lisp a de plus proche d'un slogan est une description à la façon d'un koan, « le langage de programmation programmable ». Bien que cryptique, cette description va à la racine du plus gros avantage que Common Lisp a encore sur d'autres langages. Plus qu'aucun autre langage, Common Lisp suit la philosophie selon laquelle ce qui est bon pour le concepteur du langage l'est aussi ses utilisateurs. Et de fait, quand vous programmez en Common Lisp, vous ne vous trouverez pratiquement jamais à souhaiter que le langage possède une quelconque caractéristique qui rendrait votre programme plus simple à écrire parce que, comme vous le verrez tout au long de ce livre, vous pourrez ajouter cette caractéristique vous-même.

En conséquence, un programme en Common Lisp a tendance à manifester une correspondance beaucoup plus claire entre vos idées sur le fonctionnement du programme et le code que vous écrivez effectivement. Vos idées ne sont pas obscurcies par du code type (NdT: boilerplate) et des idiomes répétés sans fin. Cela rend votre code plus facile à maintenir parce que vous n'avez pas à patauger à travers des monceaux de code à chaque fois que vous avez besoin de changer quelque chose. Même des changements systémiques du comportement d'un programme peuvent souvent être obtenus par des  changements relativements légers du code lui-même. Cela signifie aussi que vous allez développer du code plus rapidement ; il y a moins de code à écrire, et vous ne gaspillez pas de temps à vous évertuer à trouver une façon élégante de vous exprimez malgré les limitations du langage.

Common Lisp est également un excellent langage pour la programmation exploratoire -- si vous ne savez pas exactement comment votre programme va fonctionner quand vous vous mettez à l'écrire, Common Lisp a de nombreuses caractéristiques qui vous aideront à développer votre code incrémentalement et interactivement.

En hors d'oeuvre, la boucle lis-éval-imprime, que j'introduirai dans le chapitre suivant, vous permet d'interagir continuellement avec votre programme alors que vous le développez. Écrivez une nouvelle fonction. Testez la. Changez la. Essayez une approche différente. Vous n'avez jamais besoin de vous arrêter à cause d'un long cycle de compilation.

Parmi les autres caractéristiques qui permettent un style de programmation coulant et interactif, il y a le typage dynmaique de Lisp et le système de condition de Common Lisp. Grâce au premier, vous passez moins de temps à convaincre le compilateur que vous devriez avoir le droit d'exécuter votre code et plus de temps à effectivement le faire tourner et à travailler dessus et le second vous permet de développer même votre code de gestion d'erreur interactivement.

Une autre conséquence du fait d'être un « langage de programmation programmable » est que Common Lisp, en plus d'incorporer de légers changements qui rendent certains programmes particuliers plus faciles à écrire, peut facilement adopter des idées radicalement nouvelles sur le fonctionnement des langages de programmation. Par exemple, l'implémentation originelle du Common Lisp Object System (CLOS), le puissant système object de Common Lisp, était une bibliothèque écrite en Common Lisp portable. Cela permit aux programmeurs Lisp de gagner une véritable expérience avec les fonctionnalités qu'il fournissait, avant qu'il soit officiellement incorporé dans le langage.

Quelque soit le nouveau paradigme qui fasse son apparition ensuite, il est extrêmement probable que Common Lisp soit capable de l'absorber sans nécessiter aucun changement au noyau du langage. Par exemple, un Lispeur a récemment écrit une bibliothèque, AspectL, qui ajoute le support pour la programmation orientée aspect (POA) à Common Lisp. Si la POA s'avère être le prochain gros concept(Td:?), Common Lisp sera capable de le supporter sans aucun changement au langage de base et sans aucun préprocesseur additionnel ou compilateur additionnel.

===== Comment tout a commencé =====

Common Lisp est le déscendant moderne du langage Lisp conçu initialement par John !McCarthy en 1956. Lisp aux alentours de 1956 fut conçu pour le « traitement de données symboliques » et dériva son nom d'une des choses pour lesquelles il était plutôt bon : LISt Processing (NdT: traitement de liste).
