====== TraductionPcl ======
Created samedi 16/12/2006

cf. [[TraductionPclConventions]]

====== Introduction : pourquoi Lisp ? ======

Si vous pensez que le plus grand plaisir dans le fait de programmer vient de pouvoir faire le plus possible avec du code qui exprime simplement et clairement votre intention, alors programmer en Common Lisp devrait sûrement être ce que vous pourriez faire de plus amusant avec un ordinateur. Vous ferez plus et plus vite en l'utilisant que vous ne pourriez avec aucun autre langage.

C'est une affirmation osée. Est-ce que je peux la justifier ? Pas avec seulement les quelques pages de ce chapitre -- vous allez devoir apprendre un peu de Lisp et voir par vous-même -- d'où ce livre. Pour le moment, commençons par une preuve anecdotale, l'histoire de mon chemin jusqu'à Lisp. Puis, dans la section suivante, j'expliquerai quel bénéfice je pense que vous aurez à apprendre Common Lisp.

Je suis l'un de ce qui doit être un relativement petit nombre de hackers Lisp de seconde génération. Mon père débuta dans l'informatique en écrivant un système d'exploitation en assembleur pour la machine qu'il utilisait pour collecter des données pour sa thèse de physique. Après avoir utilisé des systèmes informatiques dans divers labos de physique, dans les années 80 il avait complètement quitté la physique et travaillait pour une grosse société pharmaceutique. Cette société avait comme projet en cours de développer un logiciel pour modéliser les processus de production de ses usines chimiques -- si vous augmentez la taille de ce vaisseau(Td: cette tubulure?),  comment cela affecte-t-il la production annuelle ? L'équipe originelle, qui écrivait en FORTRAN, avait dilapidé la moitié du budget et pratiquement tout le temps alloué au projet avec rien pour prouver leurs efforts. Comme c'était les années 80 et le milieu du boom de l'intelligence artificielle (IA), Lisp était dans l'air du temps. Et donc mon père -- pas un Lispeur à ce moment-là -- alla à la Carnegie Mellon University (CMU) pour parler avec quelqu'uns des gars(Td:?) qui travaillaient sur ce qui allait devenir Common Lisp pour savoir si Lisp pourrait être un bon langage pour ce projet.

Les gars de CMU lui montrèrent quelques démos des trucs sur lesquels ils travaillaient, et il fut convaincu. À son tour, il convainquit ses patrons de laisser son équipe reprendre le projet en échec et de le faire en Lisp. Un an plus tard, et en utilisant seulement ce qui restait du budget original, son équipe livra une application fonctionnelle avec des options que l'équipe originale avait abandonné de livrer. Mon père accorde le succès de son équipe à leur décision d'utiliser Lisp.

Maintenant, ce n'est qu'une anecdote. Et peut-être mon père se trompe-t-il à propos des raisons de leur succès. Ou peut-être que Lisp était meilleur seulement en comparaison des autres langages du moment. De nos jours, nous avons tout un tas de nouveau langages extraordinaires dont beaucoup ont incorporé des caractéristiques de Lisp. Est-ce que j'affirme vraiment que Lisp peut vous offrir les mêmes bénéfices qu'il a offert à mon père dans les années 80 ? Lisez la suite.

Malgré tous les efforts de mon père, je n'ai jamais appris aucun Lisp au lycée. Après une carrière qui ne comportait vraiment de programmation dans aucun langage, je fus séduit par le Web et de retour dans l'informatique. J'ai travaillé d'abord en Perl, apprenant assez pour devenir dangereux tout en ayant mis au point un forum de discussion en ligne pour le site Web du magazine //Mother Jones// et ensuite changé pour un magasin en ligne, Organic Online, où j'ai travaillé sur de gros -- pour l'époque -- sites Web tel que celui que Nike afficha durant les jeux olympiques de 1996. Plus tard je me suis mis à Java en tant parmi les premiers développeurs chez WebLogic, qui fait maintenant partie de BEA. Après WebLogic, j'ai rejoint une autre start-up où j'étais le programmeur en chef d'une équipe qui mettait au point un système de messagerie transactionnel en Java. Durant ce temps, mon intérêt en général pour les langages de programmation m'amena à explorer des langages classiques tels que C, C++ et Python aussi bien que des certains moins connus tels que Smalltalk, Eiffel et Beta.

Donc je connaissais deux langages d'un bout à l'autre et était familier avec une douzaine d'autres. Finalement, pourtant, je réalisai que mon intérêt pour les langages de programmation était enraciné dans l'idée, plantée par les récits sur Lisp de mon père -- que des langages différents étaient vraiment différents, et que, malgré l'équivalence formelle de Turing entre tous les langages de programmation, vous pouvez vraiment en faire plus, plus rapidement, dans certains langages et prendre du plaisir à le faire. Pourtant, ironiquement, je n'avais jamais vraiment passé beaucoup de temps sur Lisp lui-même. Je commençai donc à bricoler (NdT: hacking) avec Lisp sur mon temps libre. Et chaque fois que je le faisais, c'était grisant de voir à quelle vitesse je pouvais passer de l'idée à un code qui marche.

Par exemple, pendant des vacances, ayant à peu près une semaine pour bricoler Lisp, je décidai de m'essayer à écrire une version d'un programme -- un système pour élever des algorithmes génétiques pour jouer au Go -- que j'avais écrit au début de ma carrière de programmeur Java. Même handicapé par ma connaissance rudimentaire de Common Lisp et devant chercher mêmes les fonctions basiques, cela sembla plus productif que si j'avais du réécrire le même programme en Java, même avec plusieurs années en plus d'expérience avec Java, acquise depuis l'écriture de la première version.

Une expérience similaire amena à la bibliothèque dont je parlerai au chapitre 24. À mes débuts chez WebLogic, j'avais écrit une bibliothèque, en Java, pour disséquer des fichiers de classe Java. Cela marchait, mais le code était un peu en fouillis et difficile à modifier ou étendre. J'avais essayé de nombreuses fois, au fil des ans, de réécrire cette bibliothèque, pensant qu'avec mes compétences en Java qui ne cessaient de s'améliorer, je trouverais une manière d'y parvenir qui ne finirait pas en piles de code dupliqué. Je n'ai jamais trouvé la manière. Mais quand j'ai essayé de le faire en Common Lisp, il me fallut deux jours, et je me retrouvais non seulement avec un analyseur de de fichier de classe Java, mais avec une bibliothèque généraliste pour disséquer n'importe quel type de fichier binaire. Vous verrez comment cette bibliothèque fonctionne au chapitre 24 et vous l'utiliserez au chapitre 25 pour écrire un analyseur pour les balises ID3 intégrées dans les fichiers MP3.

===== Pourquoi Lisp ? =====

Il est difficile, en seulement quelques pages d'introduction, d'expliquer pourquoi ses utilisateurs apprécient un langage et il est encore plus difficile de démonter(Td:?) pourquoi vous devriez donner de votre temps pour apprendre un certain langage. Seule notre histoire personnelle nous y conduit. J'aime peut-être Lisp à cause de bizarreries dans la façon dont mon cerveau est câblé. Cela pourrait bien être génétique, puisque mon père a ça aussi. Aussi, avant de plonger dans l'apprentissage de Lisp, il est raisonnable de vouloir savoir ce que le bénéfice serait.

Pour certains langages, le bénéfice est évident. Par exemple, si vous voulez écritre du code bas niveau pour Unix, vous devriez apprendre C. Et si vous voulez écrire certains genres d'applications multi-plateformes, vous devriez apprendre Java. Et il y a tellement de sociétés qui utilisent beacoup de C++, donc si vous voulez un emploi dans l'une d'entre elles, vous devriez apprendre C++.

Pour la plupart des langages, néanmoins, le bénéfice est plus dur à déterminer ; il est lié à des critères subjectifs tel que l'effet que cela fait d'utiliser le langage. Les défenseurs de Perl aiment à dire que Perl « rend les choses faciles faciles et les choses difficiles possibles » et se réjouissent du fait que, comme le dit le slogan de Perl, « Il y a plus d'une façon de le faire. ». Les fans de Python, d'un autre côté, pensent que Python et propre et simple et pensent que du code Python est plus facile à comprendre parce que, comme //leur// slogan le dit, « Il n'y a qu'une façon de le faire. ».

Alors, pourquoi Common Lisp ?